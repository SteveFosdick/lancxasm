# LaXasm

A portable 6502 assembler with syntax similar to ADE or the Lancaster
Assembler.

Copyright (C) Steve Fosdick 2021

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program, as COPYING.txt.  If not, see
http://www.gnu.org/licenses

## CONTENTS

1. [ABOUT LAXASM](#1-ABOUT-LAXASM)
2. [COMMAND LINE OPTIONS](#2-COMMAND-LINE-OPTIONS)
3. [SOURCE FILE SYNTAX](#3-SOURCE-FILE-SYNTAX)
4. [ASSEMBLER DIRECTIVES](#4-ASSEMBLER-DIRECTIVES)
5. [CONDITIONAL ASSEMBLY](#5-CONDITIONAL-ASSEMBLY)
6. [MACROS](#6-MACROS)
7. [COMPATIBILITY](#7-COMPATIBILITY)

## 1. ABOUT LAXASM

LAXASM is a macro assembler for the 6502 microprocessor designed
primarily to assemble code for the BBC Microcomputer and the Acorn
Electron, though it may be useful for other systems too.

The motivation for writing this assembler was to have a cross assembler
suitable for running under Linux or Windows that understands a syntax
that may also be assembled with a native assembler running on a BBC
micro.

There are two native assemblers for the BBC micro: ADE (later ADE+)
by System Software and the 65C02 Macro Assembler written by
Alan Philips of Lancaster University which implement both the standard
6502 operation syntax and a common subset of useful assembler directives.

This cross assembler implements that common subset along with some of
the extra directives implemented by each of those assemblers.

## 2. COMMAND LINE OPTIONS

### General Options

`-a`

This causes LAXASM to consider only the first six characters of a
symbol as significant.  This is for compatibility with the original
(non plus) version of ADE.

`-d`

This causes LAXASM to output a dump of all global symbols to
standard output in a format suitable for Swift (an editor).  Symbols
in this format may also be imported into the b-em debugger.

`-l <filename>`

Enable the generation of an assembly listing and specify the name of
the file to which it should be written.

`-o <filename>`

Specify the name of an object file.  If this option is not given then
no object file is created.

`-p <lines>`

Set the length of the page used in the listing.

`-r`

Restrict the set of 6502 opcodes to those on the original NMOS processor
excluding those of the 65C02.

`-w <columns`

Specify the width of the listing in columns.  This does not cause the
listing to be truncated but does set the position of items
right-justified in the header and the width of the symbol table
listing at the end.

### Listing Detail

The options with capital letters control the amount of detail included
in the listing.

`-A`

List all code bytes generated except the CODE directive which includes
a binary file verbatim in the object file.  If this option if not
specified only up to three bytes of output code are listed for each
input line which is sufficient for all 6502 instructions but does not
show all the bytes generated by some data placement directives.

`-C`

When -A (above) is also in effect this causes even the binary code
copied into the object file by the CODE directive to be added to the
listing.  This can make the listing very long.

`-F`

Use a form-feed between pages of the listing.  This may be useful if it
is intended to print the listing afterwards, though the assembler does
attempt to drive a printer directly.  If this is not specified but
page breaks are enabled a blank line is left immediately before a page
break.

`-L`

Omit the source line number from the listing line.

`-M`

Omit from the listing the lines generated by macro expansion and
therefore also the code generated by them.

`-P`

Do not include a page header or any page breaks in the listing.

`-S`

Do not include, in the listing, input lines skipped because of
conditional assembly.  Without this option these lines are included
in the listing with an 'S' to show they were not assembled.

`-T`

Suppress the inclusion of a symbol table at the end of the listing.

## 3. SOURCE FILE SYNTAX

An input line consists of the fields:

`label opcode operand comment`

all of which are optional, so a line may be completely blank, though
some assembler directives (in the opcode field) require a label to be
present and some opcodes and directives need an operand.  For example:
```
OSWRCH  EQU  &FFEE
message CSTR "Hello, World"
start   LDX  message    ; fetch the count of charcters.
        LDY  #0         ; start at the beginning.
loop    LDA  message,Y
        JSR  OSWRCH     ; Sent to the OS output routine.
        INY
        DEX
        BNE  loop       ; go back for the next character.
```

### Labels

Labels are recognised by not being preceded by white space, i.e. by
beginning at the start of the line.  A label may begin with either a
letter, for a global label or macro name, or a ':' for a local label.
After the initial character further characters may be letters, numbers
and the characters '.' (dot), '$' (dollar) and _ (underscore).  The
label may optionally be terminated by a colon and is separated from
the opcode by white space.

### Comments

Comments are introduced by any of the characters ';' (semicolon),
'\\' (backslash) or '*' (asterisk).  They continue to the end of the
line.

### Expressions

Expressions may contain literal numbers, symbols (labels or values
set with EQU) operators and brackets.  Literal numbers may be prefixed
to use a base other than decimal:

```
& or $ - hexadecimal
%      - binary
```

Operators are evaluated in precedence order as follows, working from
highest to lowest:
```
() - brackets

-  - unary minus (negate value).
~  - unary 1's complement (NOT)

&  - bit wise AND.
!  - bit wise OR.

=  - test for equality
#  - test for inequality
>  - (infix) greater than.
<  - (infix) less than.

*  - multiply
/  - divide

+  - add
-  - subtract.

>  - (prefix) take the low byte.
<  - (prefix) take the high byte.
```

## 4. ASSEMBLER DIRECTIVES

### General

`EQU <expr>`

This requires a label and sets the label concerned to the value of the
expression.

`ORG <expr>`

Set the current location counter for which code will be assembled.

`BLOCK`

Begin a new scope for local labels.  If a local label is present on
the same line as the _BLOCK_ directive it is entered into the old
local label scope, i.e before the _BLOCK_ takes effect.

### Reserving Space

`DSECT`

Begin a dummy (data) section.  This enables areas of memory to be laid
out with data placement/reservation instructions without generating
any output.  A separate location counter is kept for dummy sections
and the main body of the file so when DSECT is encountered for the
first time it will start working from location zero until this is
reset with an ORG directive.  Second and subseqent DSECTs will continue
from where the previous DSECT finishedm though this may still be reset
by ORG.  DSECTs do not nest.

`DEND`

Finish a dummy (data) section.  This remembers the location counter
from the DSECT, so it may be restored when another DSECT is encountered,
and returns location counter usage to that of the main body of the
assembly.

`DS <expr>`

Define space.  This advances the location pointer by the value of the
expression.  If used outside a DSECT, the space is padded with zero
bytes.

### Planting Numeric Data

For all of these operations the expression may be preceded by a count
in square brackets to plant that many copies of the data item, for
example:

`DB [10]&FF`

which plants 10 bytes of value &FF in a row.

`DDB <expr> [,<expr>...]` or `DFDB <expr> [,<expr>...]`

Define double-byte.  This plants the value of the expression as a pair
of bytes in big-endian order, i.e. the opposite from the one used by
the 6502.

`DFB <expr> [,<expr>...]`

Define byte.  Plant the low 8-bits of the expression as a single byte.

`DFW <expr> [,<expr>...]` or `DW  <expr> [,<expr>...]`

Define word.   This plants the value of the expression as a pair
of bytes in little-endian order, i.e. the normal order used by
the 6502.

`HEX <string>`

Take the string, which is expected to consist only of hexadecimal
digits, and plant a byte for each pair of digits.  Invalid hex digits
cause an error to be generated.

### Planting String Data

`ASC <string>`

Plant string data as specified in the string.  The string may be
delimited by either single or double quotes.  If one style of quote
is needed in the string then delimit the string with the other one.
In the string there are two characters with special meaning:

A bar (|) symbol causes the following character to have all but its
least significant five bits masked off.  This causes the letter
characters to turn into their equivalent control characters, this a
CR can be included with |M, a linefeed with |J and a BEL as |G.

A caret (^) symbol causes the following character to have bit 7 set.

To include either of these characters literally in the string it should
be doubled, i.e. || and ^^ respectively.

`STR <string>`

As _ASC_ above but automatically adds a carriage-return at the end.

`CASC <string>`

As _ASC_ above but prefix the string concerned with its length as a
single byte.

`CSTR <string>`

As _STR_ above but prefix the string concerned with its length as a
single byte.  The count includes the automatically added CR.

### File Control

`CODE <filename>`

Read the specified file as binary and include its contents literally
into the generated object code.

`INCLUDE <filename>`

Include the contents of the specified file in the assembly.  When the
end of this file is reached return to the file previously being
assembled.  While a file is being included this is indicated in the
listing with an 'I'.  Note that if this is invoked from a MACRO,
assembly immediately switched to the included files and expansion of
the MACRO finishes once the included file has come to an end.


`CHN <filename>`

Open the specified file and continue assembling lines from there,
skipping any remaining lines in the current file.  Note that if this
is invoked from a MACRO, expansion of the MACRO finishes before reading
of the new file begins.

`LOAD <addr>`

Set the load address for the object code.  If this, or the EXEC
directive, are used a .inf file is written for the object file to
enable the LOAD/EXEC address to be transferred into a disk image
by an external tool or interpreted by VDFS (b-em).

`EXEC <addr>`

As above but sets the execution address.

`MSW <addr>`

Set the most significant word used by both the LOAD and EXEC addresses
i.e. to control whether the code is to be loaded in the language
processor (whether this is a tube processor or not) or always in the
I/O processor.

### Interaction with the User

`DISP <message>` or `INFO <message>`

Display the specified message on stdout.  This supports the Lancaster
option of embedding numeric expressions within the message, to be
printed in decimal with `%D(expr)` or hex with `%X(expr)`

`DISP1 <message>`

As _DISP_ but only display the message on pass one.

`DISP2 <message>`

As _DISP_ but only display the message on pass two.

`QUERY <prompt>`

This directive requires a label.  The prompt is printed, anything the
user types in is evaluated as an expression, and the value of of this
expression is used to set the label.  If nothing is entered or the
expression cannot be evaluated then the prompt is repeated.  The
expression may contain symbols but forward references are not allowed.

### Listing Control

`CLST <value>`

Control the code listing level.  This works much as in the Lancaster
assembler with 0 causing only the first three bytes generated for each
line to be included in the listing, 1 causing the full set of bytes to
be included for 6502 instructions and data planting directives except
CODE, and 2 causing all bytes to be included however generated.  See
also the command line options -A and -C and _LISTO_ below.

`LST <value>`

Control the source listing level. This will accept the words **ON**,
**OFF** and **FULL** as in ADE+ or an expression that evaluates to a
number 0-3 as in the Lancaster assembler.  When **off** or zero, no
lines of the source text are included in the listing, only errors.  When
**on** or **1** lines of the source text not generated by macro
expansion are included.  When **full** or **2** lines generated by
expanding macros are also included.  See also the command line
option -M and _LISTO_ below.

`LFCOND`

Include in the listing lines skipped by conditional assembly.

`SFCOND`

Exclude from the listing lines skipped by conditional assembly. See
also the -S command line option.

`LISTO <expr>`

Set various listing options in a manner compatible with ADE+.  The
expression is evaluated and the corresponding listing option bits
are toggled.  The bits and their values are as follows with the
corresponding command line argument.

```
0 &001  -P   - suppress page breaks and header.
1 &002  -L   - turn off line numbers.
2 &004  -F   - use a form-feed between pages.
3 &008  -T   - Symbol table suppressed
4 &010  -M   - listing of macro expansion suppressed.
5 &020  -A   - more than three code bytes per input line in listing.
6 &040  -C   - bytes from codefile included in listing.
7 &080  -S   - Skipped conditional lines excluded.
8 &100       - Listing is enabled.
```

`PAGE <length>[,<width>]`

This sets the page length for a paginated listing, and optionally the
width (as per the Lancaster assembler).

`WIDTH <width>`

This sets the page width for the listing.  This does not cause lines
longer than this to be truncated but is used to right-align the
page header and for the width of the symbol table listing.

`TTL`

Set the title to be included in the header of each page.

`SKP <value>`

Skip the specified number of lines or, if 'H' is specified, to the
start of the next page.

`TABS <col>[,<col>...]`

Tabs present in the input file are expanded to spaces in the listing.
This sets the position of those tab stops.  Tab position 1 is just
after the line number in the listing, i.e. these positions relate to
the source line - there is no need to allow for the output generated
by the assembler itself.

## 5. CONDITIONAL ASSEMBLY

Conditional assembly is provided using the directives _IF_, _ELSE_
and _FI_.  The directive goes in the opcode field.  For example:
```
        IF   RAM

        ORG  $1F00   ;avoid econet and such
        JMP  MAIN    ;JMP to make dehexer easy
        DFB  MARK    ;mark number
        DFB  VERSION ;version number
        DW   DEFTAB  ;address of defaults block
PTPPTR  DW   PRGTOP  ;first byte past image and patches
        ASC '(C)1987 CUCCA/Lancaster '
        ASC 'By A. Phillips'

        ELSE

        ORG $8000
        JMP MAIN    ;language entry point
        JMP SENTRY  ;service entry point
        DFB %11000010 ;ROM type byte
        DFB CPRMES-$8000 ;copyright offset
        DFB MARK    ;mark number
TITLE   ASC 'KERMIT' ;ROM title
ROMCLN  EQU *-TITLE-1
        DFB 0
        DFB MARK+$30
        DFB '.'
        DFB VERSION/10+$30
        DFB (VERSION-(VERSION/10*10))+$30
CPRMES  DFB 0
        ASC '(C)1987 CUCCA/Lancaster'
        DFB 0

        FI
```

There is no _ELSIF_.  Conditionals can be nested to a depth of 32.

When the assembler is scanning for a matching _FI_ directive it needs
to be able to parse the label field and find the opcode fields so these
must be correct, however labels are not assigned and expressions are
not evauluated.

## 6. MACROS

Macros are defined using the _MACRO_ and _ENDM_ directives, for example
```
SPCOUT  MACRO
        LDA  #' '
        JSR  OSWRCH
        ENDM
```
Up to nine user arguments may be passed to macros; these are not
declared as part of the _MACRO_ dcirective but are referred to by number
within the body of the macro, preceded by an @ sign, for example:
```
SPACES  MACRO
        PHA
        TXA
        PHA
        LDX #@1
        LDA ' '
LP@0    JSR OSWRCH
        DEX
        BPL LP@0
        PLA
        TAX
        PLA
        ENDM
```
This also demonstrates a special argument, @0, which is set to a unique
macro invocation number by the assembler and can therefore be used to
define labels that are unique each time the macro is expanded

A macro may not be defined while defining an existing macro, i.e.
the _MACRO_ directive does not nest but calls to macros do nest.  In
this case @0 is saved and restored around the nested macro call so the
calling macro can still refer to its own symbols.

Macro expansion happens in the text domain so, for example, strings
may be composed of fragments passed in as macro arguments.  For example:
```
OPNERR  MACRO
        BRK
        DFB  @1
        ASC  "Unable to open @2 for @3"
        DFB  0
        ENDM
; ...
        OPNERR &94,Input file,reading
```

## 7. COMPATIBILITY

### In General

This assembler does not, at present, implement any feature that causes
the same statement to have to processed more than once within the same
pass so there there are no REPEAT  or WHILE loops and no GOTO.

The directives _SYSCLI_, _SYSFX_, _SYSVDU_, _SYSVDU1_ and _SYSVDU2_ are
recognised but do nothing except cause a warning to be issued.

### With the Lancaster Assembler.

LaXasm does not implement the Lancaster "Assemble Time Variables"
(ATVs) in either global or local form or any of the directives associated
with them.

The precedence levels in expression parser are those from the Lancaster
Assembler.

The following directives, implemented by the Lancaster Assembler and not
by ADE, are implemented in LaXasm: _CASC_, _CLST_, _CODE_, _CSTR_,
_DFDB_, _DFW_, _DISP_, _DISP1_, _DISP2_, _LFCOND_, _LOAD_, _SFCOND_
and _TABS_.

The following directives, implemented by the Lancaster Assembler and not
by ADE, are **NOT** implemented in LaXasm: _AGO_, _AIF_, _AIFDEF_,
_AIFNDEF_, _ALEN_, _ASET_, _ASTR_, _ASTRIP_, _CHR_, _DEFPARS_,
_MEXIT_, _MLEN_, _MSET_, _MSTR_, _MSTRIP_,
_REP_, _SYSVDU1_, _SYSVDU2_, _TIME_, _WAIT_, _WAIT1_, _WAIT2_.

### With ADE/ADE+

LaXasm does not implement separately assembled or relocatable modules
with separate linking or any of thd directives associated with those
features.

In ADE expression evaluation is left to right.  In LaXasm it follows
operator precedence.

The following directives, implemented by ADE+ and not by the Lancaster
Assembler, are implemented in LaXasm: _BLOCK_, _DATA_, _LISTO_, _WIDTH_.

The following directives, implemented by ADE+ and not by the Lancaster
Assembler, are **NOT** implemented in LaXasm: _ASECT_, _EMBED_,
_END_, _ENT_, _EXT_, _EXZ_, _GEQU_, _GET_, _LLST_, _MACLIB_, _MODULE_,
_MSB_, _NOLIB_, _OBJ_, _OPT_, _PAUSE_, _QSTR_, _REPEAT_, _RESUME_,
_RSECT_, _RZP_, _UNTIL_, _WEND_, _WHILE_
